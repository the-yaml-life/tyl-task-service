# üèóÔ∏è TYL Microservice Template

Este template proporciona una base completa y lista para producci√≥n para crear microservicios con el framework TYL, implementando arquitectura hexagonal y patrones event-driven.

## üöÄ Quick Start

### Generar un nuevo microservicio

```bash
# Syntax: ./scripts/create-microservice.sh <service-name> <ServiceClass> <DomainModel> [github-org] [output-dir]

# Ejemplo: Crear un servicio de √≥rdenes (usa the-yaml-life por defecto)
./scripts/create-microservice.sh order-service OrderService Order

# Ejemplo: Crear un servicio de autenticaci√≥n en tu organizaci√≥n
./scripts/create-microservice.sh user-auth UserAuthService User my-org

# Ejemplo: Crear un servicio de pagos con directorio custom
./scripts/create-microservice.sh payment-gateway PaymentService Payment my-org ~/my-services
```

**Prerequisites:**
- [GitHub CLI](https://cli.github.com/) instalado y autenticado
- Git configurado correctamente
- Permisos para crear repos en la organizaci√≥n especificada

### Despu√©s de la generaci√≥n

```bash
cd ../tyl-order-service  # (o el directorio generado)

# Compilar y ejecutar
cargo run

# Ejecutar tests
cargo test

# Usar Docker
docker-compose up
```

## üìã Par√°metros del Template

| Par√°metro | Descripci√≥n | Ejemplo | Transformaciones |
|-----------|-------------|---------|------------------|
| **service-name** | Nombre kebab-case del servicio | `order-service` | ‚Üí `tyl-order-service` (package name) |
| **ServiceClass** | Nombre PascalCase de la clase principal | `OrderService` | ‚Üí `OrderServiceConfig`, `OrderServiceError` |
| **DomainModel** | Nombre PascalCase del modelo de dominio | `Order` | ‚Üí `CreateOrderRequest`, `OrderResponse` |

### Variables generadas autom√°ticamente:

- **task-service** ‚Üí `order-service`
- **task_service** ‚Üí `order_service`
- **TASK_SERVICE** ‚Üí `ORDER_SERVICE`
- **TaskService** ‚Üí `OrderService`
- **TaskService** ‚Üí `OrderService`
- **Task** ‚Üí `Order`
- **task** ‚Üí `order`
- **task** ‚Üí `order`

## üèóÔ∏è Arquitectura del Template

### Estructura de directorios generada:

```
tyl-{service-name}/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.rs                 # Entry point
‚îÇ   ‚îú‚îÄ‚îÄ lib.rs                  # Library exports y setup
‚îÇ   ‚îú‚îÄ‚îÄ config.rs               # Configuration management
‚îÇ   ‚îú‚îÄ‚îÄ domain.rs               # Business logic y domain models
‚îÇ   ‚îú‚îÄ‚îÄ routes.rs               # HTTP route definitions
‚îÇ   ‚îú‚îÄ‚îÄ handlers/               # HTTP request handlers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.rs              # Business logic endpoints
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ health.rs           # Health check endpoints
‚îÇ   ‚îú‚îÄ‚îÄ adapters/               # External integrations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.rs         # Database abstraction
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ http_client.rs      # External HTTP services
‚îÇ   ‚îî‚îÄ‚îÄ events/                 # Event-driven architecture
‚îÇ       ‚îú‚îÄ‚îÄ mod.rs              # Event system exports
‚îÇ       ‚îú‚îÄ‚îÄ service.rs          # Event publishing/subscription
‚îÇ       ‚îú‚îÄ‚îÄ handlers.rs         # Event handler traits
‚îÇ       ‚îî‚îÄ‚îÄ examples.rs         # Domain event examples
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ api_tests.rs            # API endpoint tests
‚îÇ   ‚îî‚îÄ‚îÄ integration_tests.rs    # Integration tests
‚îú‚îÄ‚îÄ examples/
‚îÇ   ‚îú‚îÄ‚îÄ basic_usage.rs          # Basic usage example
‚îÇ   ‚îî‚îÄ‚îÄ event_driven_usage.rs   # Event-driven examples
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ development.toml        # Development config
‚îÇ   ‚îî‚îÄ‚îÄ production.toml         # Production config
‚îú‚îÄ‚îÄ docker/
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile              # Container definition
‚îÇ   ‚îú‚îÄ‚îÄ docker-compose.yml      # Local development
‚îÇ   ‚îî‚îÄ‚îÄ init.sql                # Database initialization
‚îú‚îÄ‚îÄ .env.example                # Environment variables template
‚îú‚îÄ‚îÄ Cargo.toml                  # Package configuration
‚îú‚îÄ‚îÄ README.md                   # Project documentation
‚îú‚îÄ‚îÄ CLAUDE.md                   # Implementation details
‚îî‚îÄ‚îÄ TEMPLATE.md                 # Este archivo
```

### Arquitectura Hexagonal

El template implementa **arquitectura hexagonal** con estas capas:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   HTTP API      ‚îÇ    ‚îÇ   Event Bus     ‚îÇ    ‚îÇ   Database      ‚îÇ
‚îÇ   (Adapters)    ‚îÇ    ‚îÇ   (Adapters)    ‚îÇ    ‚îÇ   (Adapters)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                       ‚îÇ                       ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 ‚îÇ
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   Domain Core   ‚îÇ
                    ‚îÇ  ({{ServiceClass}}) ‚îÇ
                    ‚îÇ ({{DomainModel}})  ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üéØ Patrones Implementados

### 1. **Domain-Driven Design**
```rust
// Dominio rico con business logic
pub trait TaskService {
    async fn process(&self, request: CreateTaskRequest) -> TaskServiceResult<TaskResponse>;
    async fn get_by_id(&self, id: &str) -> TaskServiceResult<Option<Task>>;
    async fn create(&self, data: CreateTaskRequest) -> TaskServiceResult<Task>;
    async fn update(&self, id: &str, data: UpdateTaskRequest) -> TaskServiceResult<Task>;
    async fn delete(&self, id: &str) -> TaskServiceResult<()>;
}
```

### 2. **Repository Pattern**
```rust
// Abstracci√≥n de persistencia
pub trait TaskRepository: Send + Sync {
    async fn find_by_id(&self, id: &str) -> TaskServiceResult<Option<Task>>;
    async fn save(&self, task: &Task) -> TaskServiceResult<()>;
    async fn update(&self, task: &Task) -> TaskServiceResult<()>;
    async fn delete(&self, id: &str) -> TaskServiceResult<()>;
}
```

### 3. **Event-Driven Architecture**
```rust
// Publishing events
let event = TaskCreated {
    task_id: task.id,
    created_at: Utc::now(),
};

event_service.publish("task.created", event).await?;

// Handling events
#[async_trait]
impl DomainEventHandler<TaskCreated> for TaskCreatedHandler {
    async fn handle_domain_event(&self, event: TaskCreated) -> HandlerResult {
        // Handle the event
        Ok(())
    }
}
```

### 4. **Configuration Management**
```rust
// Configuraci√≥n tipada y validada
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TaskServiceConfig {
    pub service_name: String,
    pub version: String,
    pub api: ApiConfig,
    pub database: Option<DatabaseConfig>,
    pub external: ExternalConfig,
    pub monitoring: MonitoringConfig,
}
```

## üß™ Testing Strategy

El template incluye testing completo:

### Unit Tests
- Tests de cada m√≥dulo individual
- Mocks para dependencies externas
- Coverage de business logic

### Integration Tests
- Tests end-to-end de APIs
- Tests de integraci√≥n entre componentes
- Tests con datos realistas

### API Tests
- Tests espec√≠ficos de endpoints HTTP
- Validaci√≥n de request/response
- Tests de error handling

### Event Tests
- Tests de publishing/subscribing
- Tests de event handlers
- Tests de integration entre eventos

## üîß Customizaci√≥n Post-Generaci√≥n

### 1. **Implementar Business Logic**

Edita `src/domain.rs`:
```rust
impl TaskService for TaskServiceImpl {
    async fn create(&self, data: CreateTaskRequest) -> TaskServiceResult<Task> {
        // 1. Validar datos
        self.validate_task(&data)?;
        
        // 2. Crear entidad
        let task = Task::new(data);
        
        // 3. Persistir
        self.repository.save(&task).await?;
        
        // 4. Publicar evento
        let event = TaskCreated::from(&task);
        self.event_service.publish("task.created", event).await?;
        
        Ok(task)
    }
}
```

### 2. **Configurar Database**

Edita `src/adapters/database.rs`:
```rust
impl TaskRepository for PostgresTaskRepository {
    async fn save(&self, task: &Task) -> TaskServiceResult<()> {
        sqlx::query!(
            "INSERT INTO tasks (id, name, status, created_at) VALUES ($1, $2, $3, $4)",
            task.id,
            task.name,
            task.status as _,
            task.created_at
        )
        .execute(&self.pool)
        .await?;
        
        Ok(())
    }
}
```

### 3. **Definir Domain Events**

Edita `src/events/examples.rs`:
```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct TaskCreated {
    pub task_id: String,
    pub name: String,
    pub created_at: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TaskUpdated {
    pub task_id: String,
    pub changes: HashMap<String, serde_json::Value>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}
```

### 4. **Configurar Production Environment**

Edita `config/production.toml`:
```toml
service_name = "task-service"
version = "1.0.0"

[api]
host = "0.0.0.0"
port = 8080

[database]
url = "${DATABASE_URL}"
max_connections = 20

[monitoring]
enable_tracing = true
enable_metrics = true
```

## üê≥ Deployment con Docker

### Development
```bash
# Start all services
docker-compose up

# Access service
curl http://localhost:3000/health
```

### Production
```bash
# Build image
docker build -t tyl-task-service -f docker/Dockerfile .

# Run container
docker run -p 8080:8080 \
  -e DATABASE_URL=postgres://... \
  -e RUST_LOG=info \
  tyl-task-service
```

## üìö Recursos Adicionales

### TYL Framework Components
- **tyl-errors**: Manejo comprehensivo de errores
- **tyl-config**: Gesti√≥n de configuraci√≥n
- **tyl-logging**: Logging estructurado
- **tyl-tracing**: Distributed tracing
- **tyl-pubsub-port**: Event-driven architecture

### External Dependencies
- **Axum**: Web framework moderno
- **Tokio**: Async runtime
- **Serde**: Serialization
- **Sqlx**: Database toolkit (opcional)
- **Tracing**: Observability

## üîÑ Evolution Path

### Phase 1: Basic Implementation
1. Implementar domain logic b√°sico
2. Conectar database
3. Agregar tests unitarios

### Phase 2: Advanced Features
1. Implementar event-driven workflows
2. Agregar m√©tricas y monitoring
3. Performance tuning

### Phase 3: Production Ready
1. Security hardening
2. Load testing
3. CI/CD pipeline
4. Documentation completa

## ü§ù Best Practices Incluidas

‚úÖ **Arquitectura**: Hexagonal + Event-driven  
‚úÖ **Error Handling**: TylError integration  
‚úÖ **Testing**: Unit + Integration + API tests  
‚úÖ **Configuration**: Environment-based config  
‚úÖ **Logging**: Structured logging + tracing  
‚úÖ **Documentation**: Code + API + architecture  
‚úÖ **DevEx**: Docker + examples + scripts  
‚úÖ **Security**: Input validation + error sanitization  
‚úÖ **Performance**: Async-first + connection pooling  
‚úÖ **Monitoring**: Health checks + metrics ready  

Este template proporciona una base s√≥lida y probada para crear microservicios de production-grade con el framework TYL. üöÄ